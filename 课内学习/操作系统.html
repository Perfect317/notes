<!DOCTYPE html>
<html>
<head>
<title>操作系统.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81">操作系统的四个特征</h1>
<h2 id="%E5%B9%B6%E5%8F%91">并发</h2>
<p><code>概念</code>:指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的常考易混概念</p>
<p><code>并行</code>:指两个或多个事件在同一时刻同时发生。</p>
<p>单核CPU:同一时刻只能执行一个程序，各个程序只能并发地执行</p>
<p>多核CPU:同一时刻可以同时执行多个程序，多个程序可以并行地执行</p>
<h2 id="%E5%85%B1%E4%BA%AB">共享</h2>
<p><code>共享</code>:即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<h3 id="%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">两种方式</h3>
<p><code>互斥共享方式</code>：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源
<code>同时共享方式</code>：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问</p>
<h2 id="%E8%99%9A%E6%8B%9F">虚拟</h2>
<p><code>虚拟</code>:是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上对应物(后者)是用户感受到的。</p>
<h2 id="%E5%BC%82%E6%AD%A5">异步</h2>
<p><code>异步</code>:在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<h1 id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB">操作系统的分类</h1>
<h2 id="1%E6%89%B9%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5--%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">1.批处理阶段--单道批处理系统</h2>
<p><img src="操作系统/image-20241219171111530.png" alt="image-20241219171111530"></p>
<p><strong>主要缺点</strong>:内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/0完成。资源利用率依然很低。</p>
<h2 id="2%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F--%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">2.批处理系统--多道批处理系统</h2>
<p><img src="操作系统/image-20241219171147905.png" alt="image-20241219171147905"></p>
<p><strong>主要优点</strong>:多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大，
<strong>主要缺点</strong>:用户响应时间长，<font color=red>没有人机交互功能</font>&gt;(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg:无法调试程序/无法在程序运行过程中输入一些参数)</p>
<h2 id="3%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">3.分时操作系统</h2>
<p>分时操作系统:计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互主要优点:用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>
<p>作业服务一个时间片，不区分任务的紧急性
<strong>主要缺点</strong>:不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/</p>
<h2 id="4%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">4.实时操作系统</h2>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理， 并且要在严格的时限内处理完事件。实时操作系统的主要特点是<font color=red>及时性和可靠性</font></p>
<p>**硬实时系统:**必须在绝对严格的规定时间内完成处理</p>
<p>**软实时系统:**能接受偶尔违反时间规定</p>
<h1 id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">操作系统的运行机制</h1>
<h2 id="%E5%86%85%E6%A0%B8%E7%A8%8B%E5%BA%8F">内核程序</h2>
<p>内核程序只能跑特权指令</p>
<p>运行内核程序时cpu处于内核态</p>
<h2 id="%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</h2>
<p>应用程序只能跑非特权指令</p>
<p>运行应用程序时cpu处于用户态</p>
<h2 id="%E5%8F%98%E6%80%81">变态</h2>
<p>CPU中PSW的数值代表着cpu当前的状态；1是内核态，0是用户态</p>
<p><code>内核态→用户态</code>:执行一条特权指令--修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</p>
<p><code>用户态→内核态</code>:由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</p>
<h1 id="%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8">中断和异常</h1>
<p><code>中断的作用</code>：让操作系统内核强行夺回CPU的控制权，使CPU从用户态变为内核态</p>
<h2 id="%E5%88%86%E7%B1%BB">分类</h2>
<h3 id="%E5%86%85%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8">内中断（异常）</h3>
<p>陷阱、陷入，故障，终止</p>
<p><code>中断检查</code>:内中断:CPU 在执行指令时会检查是否有异常发生</p>
<h3 id="%E5%A4%96%E4%B8%AD%E6%96%AD%E4%B8%AD%E6%96%AD">外中断（中断）</h3>
<p>时钟终端，I/O中断请求</p>
<p><code>中断检查</code>:外中断:每个指令周期末尾，CPU都会检查是否有外中断信号需要处理</p>
<p>中断处理程序：每一种中断都对应一种中断处理程序，通过‘中断向量表’实现</p>
<p>中断处理程序：每一种中断都对应一种中断处理程序，通过‘中断向量表’实现</p>
<h1 id="%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</h1>
<p>“系统调用”是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，<font color=red>应用程序可以通过系统调用来请求获得操作系统内核的服务</font></p>
<p><strong>系统调用与库函数的区别：</strong></p>
<ol>
<li>有的库函数是对系统调用的进一步封装</li>
<li>有的库函数没有使用系统调用</li>
</ol>
<p><strong>什么功能要用系统调用实现?</strong></p>
<p>凡是与共享资源有关的操作、箍直接影响到其他进程的操作，一定需要操作系统介入，就需要通过系统调用来实现
传参</p>
<ol>
<li>设备管理</li>
<li>文件管理</li>
<li>进程控制</li>
<li>进程通信</li>
<li>内存管理</li>
</ol>
<h2 id="%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B">系统调用的过程</h2>
<p><img src="操作系统/image-20241219165008935.png" alt="image-20241219165008935"></p>
<p>传递系统调用参数→执行陷入指令(<font color=red>用户态</font>&gt;)→执行相应的内请求核程序处理系统调用(<font color=red>核心态</font>&gt;)→返回应用程序</p>
<h1 id="%E8%BF%9B%E7%A8%8B">进程</h1>
<h2 id="%E6%A6%82%E5%BF%B5">概念</h2>
<p>程序时静态的</p>
<p>进程是动态的</p>
<h2 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90--pcb">进程的组成--PCB</h2>
<p>当进程被创建时会分配一个<font color=red>唯一的不重复的PID</font></p>
<p>进程信息都被保存在一个<font color=red>数据结构PCB(ProcessControlBlock)中</font>，即进程控制块操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中</p>
<p>PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。</p>
<p><strong>在PCB中保存的信息：</strong></p>
<ol>
<li>进程描述信息：PID、UID</li>
<li>进程控制和管理信息：CPU、磁盘、网络流量使用情况统计.进程当前状态:就绪态/阻塞态/运行态.</li>
<li>资源分配清淡：正在使用哪些文件；正在使用哪些内存区域；正在使用哪些I/O设备</li>
<li>处理机相关信息：如PSW、PC等等各种寄存器的值(用于实现进程切换</li>
</ol>
<h2 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90--%E7%A8%8B%E5%BA%8F%E6%AE%B5%E6%95%B0%E6%8D%AE%E6%AE%B5">进程的组成--程序段、数据段</h2>
<p>程序段：程序的代码</p>
<p>数据段：运行过程中产生的各种数据</p>
<p>程序段、数据段、PCB三部分组成了<font color=red>进程实体(进程映像)</font>引入进程实体的概念后，可把进程定义为:进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>
<ul>
<li>一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行</li>
</ul>
<p><font color=red><strong>PCB是进程存在的唯一标准</strong></font></p>
<h2 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">进程的特征</h2>
<ol>
<li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的；<strong><font color=red>进程的最基本特征</font></strong></li>
<li>并发性：内存中有多个进程实体，各进程可并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制&quot;来解决异步问题</li>
<li>结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ol>
<h2 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81">进程的状态</h2>
<p>创建态（新建态）：一个进程要被创建</p>
<p>就绪态</p>
<p>运行态：正在处理机上运行</p>
<p>运行态-&gt;阻塞态（<font color=red>主动行为</font>）</p>
<p>阻塞态（等待态）：因为等待某个事件而无法继续执行，当等待的事件被运行之后就会变为就绪态</p>
<p>阻塞态-&gt;就绪态（<font color=red>被动行为</font>）</p>
<p><font color=red>注意:不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态</font>&gt;(因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求)</p>
<p>终止态（结束态）：运行结束时成为终止态</p>
<p><img src="操作系统/image-20241222184448715.png" alt="image-20241222184448715"></p>
<h2 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87">进程的组织</h2>
<p>链接方式：按招进程状态将PCB分为多个队列</p>
<p>索引方式：创建索引表</p>
<h2 id="%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6">进程控制</h2>
<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、<font color=red>实现进程状态转换</font>等功能。</p>
<h3 id="%E5%8E%9F%E8%AF%AD%E6%8E%A7%E5%88%B6">原语控制</h3>
<p>原语的执行具有原子性，即执行只能一气呵成，不允许被中断</p>
<p>可以用<font color=red>关中断</font>指令和<font color=red>开中断</font>指令这两个特权指令实现原子性</p>
<p>执行关中断指令后遇到中断指令不会中断，等执行完开中断指令后才会运行之前的中断</p>
<ul>
<li>更新PCB中的信息</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ul>
<h2 id="%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">进程通信</h2>
<h3 id="%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8">共享存储</h3>
<p><font color=red>高级：基于存储区</font>的共享:操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。</p>
<p><font color=red>低级：基于数据结构的共享</font>:比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式</p>
<h3 id="%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92">信息传递</h3>
<h4 id="%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">直接通信方式</h4>
<p>直接挂到接受进程的消息队列里</p>
<h4 id="%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">间接通信方式</h4>
<p>消息先发到中间体</p>
<h4 id="%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1">管道通信</h4>
<ol>
<li>管道只能采用<font color=red>半双工通信(只能一方写一方读，不能同时写)</font>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，
则需要设置两个管道。</li>
<li>各进程要<font color=red>互斥</font>地访问管道(由操作系统实现)</li>
<li>当管道写满时，<font color=red>写进程将阻塞</font>，直到读进程将管道中的数据取走，即可唤醒写进程。</li>
<li>当管道读空时，<font color=red>读进程将阻塞</font>，直到写进程往管道中写入数据，即可唤醒读进程。4</li>
<li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案:①<font color=red>一个管道允许多个写进程，一个读进程</font>(2014年408真题高教社官方答案);②<font color=red>允许有多个写进程，多个读进程</font>，但系统会让各个读进程轮流从管道中读数据(Linux的方案)。</li>
</ol>
<p>管道的实质是循环队列，只能顺序读取</p>
<h1 id="%E7%BA%BF%E7%A8%8B">线程</h1>
<h2 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5">线程的概念</h2>
<p><font color=red>线程成为了程序执行流的最小单位</font></p>
<p><img src="操作系统/image-20241223171026759.png" alt="image-20241223171026759"></p>
<p><font color=red>线程是一个基本的CPU执行单元</font>，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以<font color=red>并发</font>，进程内的各线程之间也可以<font color=red>并发</font>，从而进一步提升了系统的<font color=red>并发度</font>，使得一个进程内也可以并发处理各种任务(如QQ视频、文字聊天、传文件)</p>
<p>引入线程后，进程只作为除CPU之外的系统资源的分配单元(如打印机、内存地址空间等都是分配给进程的)。</p>
<h2 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7">线程的属性</h2>
<ul>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的</li>
<li>CPU每个线程都有一个线程ID、线程控制块(TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换切换</li>
<li>同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ul>
<h2 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">线程的实现方式</h2>
<h3 id="%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B">用户级线程</h3>
<p>优点：切换在用户空间即可完成，不需要切换到核心态态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行</p>
<h3 id="%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B">内核级线程</h3>
<h4 id="%E4%B8%80%E5%AF%B9%E4%B8%80">一对一</h4>
<p><img src="操作系统/image-20241224162033630.png" alt="image-20241224162033630"></p>
<p>优点：当一个线程被阻塞后，其他线程不受影响，并发能力强，多线程可在多核处理机上并行执行</p>
<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到和心态，线程管理的成本高，开销大</p>
<h4 id="%E5%A4%9A%E5%AF%B9%E4%B8%80">多对一</h4>
<p><img src="操作系统/image-20241224160859934.png" alt="image-20241224160859934"></p>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，其他也会被阻塞，并发度不高，多个线程不可再多核处理机上并行运行</p>
<p><font color=red>只有内核级线程才是处理机分配的单位</font></p>
<h4 id="%E5%A4%9A%E5%AF%B9%E5%A4%9A">多对多</h4>
<p><img src="操作系统/image-20241224161556514.png" alt="image-20241224161556514"></p>
<p>所有用户级线程都被阻塞时，这个进程才会被阻塞</p>
<p>解决了并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点</p>
<h2 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2">线程的状态与转换</h2>
<p><img src="操作系统/image-20241224162620773.png" alt="image-20241224162620773"></p>
<h3 id="tcb%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97">TCB（线程控制块）</h3>
<p>线程标识符（TID）</p>
<p>程序计数器PCP:程序目前执行到哪里</p>
<p>其他寄存器：线程运行的中间结果</p>
<p>堆栈指针：保存函数调用信息，局部变量</p>
<p>线程运行状态：运行/就绪/阻塞</p>
<p>优先级：线程调度，资源分配的参考</p>
<h1 id="%E8%B0%83%E5%BA%A6">调度</h1>
<p>按某种算法选择一个进程将处理机分配给它</p>
<h2 id="%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1">三个层次</h2>
<table>
<thead>
<tr>
<th></th>
<th>要做什么</th>
<th>调度发生的位置</th>
<th>发送频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>高级调度 (作业调度)</td>
<td>按照某种规则，从后背队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td>外存-&gt;内存（面向作业）</td>
<td>最低</td>
<td>无-&gt;创建态-&gt;就绪态</td>
</tr>
<tr>
<td>中级调度（内存调度）</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>
<td>外存-&gt;内存</td>
<td>中等</td>
<td>挂起态-&gt;就绪态（阻塞挂起-&gt;阻塞态）</td>
</tr>
<tr>
<td>初级调度（进程调度）</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td>内存-&gt;cpu</td>
<td>最高</td>
<td>就绪态-&gt;运行态</td>
</tr>
</tbody>
</table>
<h2 id="%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA">进程调度的时机</h2>
<h3 id="%E4%B8%BB%E5%8A%A8%E6%94%BE%E5%BC%83%E5%A4%84%E7%90%86%E6%9C%BA">主动放弃处理机</h3>
<p>进程正常终止</p>
<p>运行过程中发生异常而终止</p>
<p>进程主动请求阻塞</p>
<h3 id="%E8%A2%AB%E5%8A%A8%E6%94%BE%E5%BC%83%E5%A4%84%E7%90%86%E6%9C%BA">被动放弃处理机</h3>
<p>分给进程的时间片用完</p>
<p>有更紧急的事件需要处理</p>
<p>有更高优先级的进程进入就绪队列</p>
<h3 id="%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%83%85%E5%86%B5">不能进行进程调度的情况</h3>
<p>在处理中断的过程中</p>
<p>进程在操作系统内核程序临界区中</p>
<p>在原语操作过程中</p>
<p>临界资源：一个时间段只允许一个进程使用的资源，各进程需要<font color=red>互斥</font>地访问临界资源</p>
<p>临界区：访问临界资源的那段代码</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成)</p>
<p><font color=red>访问时会对该数据结构上锁，所以要让该进程迅速访问完该数据结构之后解锁，所以不能进行进程调度</font></p>
<h2 id="%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F">进程调度的方式</h2>
<h3 id="%E9%9D%9E%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%E9%9D%9E%E6%8A%A2%E5%8D%A0%E6%96%B9%E5%BC%8F">非剥夺调度方式（非抢占方式）</h3>
<p>只允许进程主动放弃处理机</p>
<h3 id="%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%E6%8A%A2%E5%8D%A0%E6%96%B9%E5%BC%8F">剥夺调度方式（抢占方式）</h3>
<p>允许处理机被动放弃</p>
<h2 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B">进程的切换与过程</h2>
<p><strong>“狭义的进程调度”与“进程切换”的区别:</strong></p>
<p><font color=red><strong>狭义的进程调度</strong></font>指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)</p>
<p><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程。</p>
<p><font color=red><strong>广义的进程调度</strong></font>包含了选择一个进程和进程切换两个步骤。
进程切换的过程主要完成了:
1.对原来运行进程各种数据的保存2.对新的进程各种数据的恢复
(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</p>
<p>注意:进程切换是有代价的，因此如果过于<font color=red>频繁</font>的进    行进程调度、切换，必然会使整个系统的效率<font color=red>降低</font>使nn 系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h2 id="%E8%B0%83%E5%BA%A6%E5%99%A8%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F">调度器/调度程序</h2>
<p><img src="操作系统/image-20241225165310621.png" alt="image-20241225165310621"></p>
<p>②和③由调度程序引起，调度程序决定：</p>
<p>让谁运行? --调度算法</p>
<p>运行多长时间？--时间片大小</p>
<h3 id="%E4%BB%80%E4%B9%88%E4%BA%8B%E4%BB%B6%E4%BC%9A%E8%A7%A6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><strong>什么事件会触发调度程序？</strong></h3>
<ul>
<li>
<p>创建新进程</p>
</li>
<li>
<p>进程退出</p>
</li>
<li>
<p>运行进程阻塞</p>
</li>
<li>
<p>I/O中断发生</p>
</li>
<li>
<p>非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作</p>
</li>
<li>
<p>抢占式调度策略，每个<font color=red>时钟中断</font>或k个时钟中断会触发调度程序工作</p>
</li>
</ul>
<h2 id="%E9%97%B2%E9%80%9B%E8%BF%9B%E7%A8%8B">闲逛进程</h2>
<p>优先级最低</p>
<p>可以是0地址指令，占一个完整的指令周期</p>
<p>能耗低</p>
<h2 id="%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87">调度算法的评价指标</h2>
<h3 id="cpu%E5%88%A9%E7%94%A8%E7%8E%87">CPU利用率</h3>
<p>利用率=忙碌的事件/总时间</p>
<h3 id="%E7%B3%BB%E7%BB%9F%E5%90%9E%E5%90%90%E9%87%8F">系统吞吐量</h3>
<p>单位时间内完成作业的数量</p>
<p>系统吞吐量=总共完成了多少道作业/总共花的时间</p>
<h3 id="%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4">周转时间</h3>
<p><strong>周转时间</strong>=作业完成时间-作业提交时间</p>
<p><strong>平均周转时间</strong>=各作业周转时间之和/作业数</p>
<p><strong>带劝周转时间</strong>=作业周转时间/作业实际运行的时间</p>
<p><img src="操作系统/image-20241225200121477.png" alt="image-20241225200121477"></p>
<p><img src="操作系统/image-20241225200130711.png" alt="image-20241225200130711"></p>
<h3 id="%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4">等待时间</h3>
<p>等待时间=周转时间-运行时间</p>
<p>作业/进程处于等待处理机状态时间之和</p>
<h3 id="%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4">响应时间</h3>
<p>用户提交请求到首次产生相应所用的时间</p>
<h2 id="%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">调度算法</h2>
<h3 id="%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1fcfs">先来先服务（FCFS）</h3>
<table>
<thead>
<tr>
<th>算法思想</th>
<th style="text-align:left">先到先服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法规则</td>
<td style="text-align:left">按照作业/进程到达的先后顺序进行服务</td>
</tr>
<tr>
<td>用于作业/进程调度</td>
<td style="text-align:left">用于作业调度时，考虑的是哪个作业先到达后备队列，用于进程调度时，考虑的是哪个进程先到达就绪队列</td>
</tr>
<tr>
<td>是否可抢占</td>
<td style="text-align:left">非抢占式算法</td>
</tr>
<tr>
<td>优缺点</td>
<td style="text-align:left">优点：公平，算法实现简单 缺点：对长作业有利，对短作业不利</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td style="text-align:left">不会</td>
</tr>
</tbody>
</table>
<h3 id="%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88sjf">短作业优先（SJF）</h3>
<table>
<thead>
<tr>
<th>算法思想</th>
<th style="text-align:left">追求最少得平均等待时间，最少的平均周转时间，最少得平均平均带劝周转时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法规则</td>
<td style="text-align:left">服务时间最短的作业优先得到服务</td>
</tr>
<tr>
<td>用于作业/进程调度</td>
<td style="text-align:left">皆可，处理进程调度时称为:<font color=red>短进程优先算法（SPF）</font></td>
</tr>
<tr>
<td>是否可抢占</td>
<td style="text-align:left">SPF和SJF是非抢占式算法,但是也有抢占式的版本--最短剩余时间优先算法（SRTN）</td>
</tr>
<tr>
<td>优缺点</td>
<td style="text-align:left">优点:“最短的”平均等待时间，平均周转时间 缺点：对短作业有利，对长作业不利，出现饥饿现象</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td style="text-align:left">会，如果一直得不到服务，则称为饿死</td>
</tr>
</tbody>
</table>
<h3 id="%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88hrrn">高响应比优先（HRRN）</h3>
<p>只有当前运行的进程主动放弃CPU时，才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机</p>
<p>响应比=等待时间+要求服务时间/要求服务时间</p>
<table>
<thead>
<tr>
<th>算法思想</th>
<th style="text-align:left">综合考虑作业/进程的等待时间和要求服务时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法规则</td>
<td style="text-align:left">在每次调度时先计算各个作业/进程的<font color=red>响应比</font>，选择<font color=red>响应比最高</font>的作业/进程为其服务</td>
</tr>
<tr>
<td>用于作业/进程调度</td>
<td style="text-align:left">皆可</td>
</tr>
<tr>
<td>是否可抢占</td>
<td style="text-align:left">非抢占式</td>
</tr>
<tr>
<td>优缺点</td>
<td style="text-align:left">综合考虑了等待时间和运行时间 等待时间相同时，服务时间短的优先 要求服务时间相同时，等待时间长的优先</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td style="text-align:left">否</td>
</tr>
</tbody>
</table>
<h3 id="%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%ACrr">时间片轮转（RR）</h3>
<table>
<thead>
<tr>
<th>算法思想</th>
<th style="text-align:left">公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法规则</td>
<td style="text-align:left">按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<font color=red>时间片</font>。若进程未在一个时间内执行完，则剥夺处理机，将进程重新放入到就绪队列尾重新排队</td>
</tr>
<tr>
<td>用于作业/进程调度</td>
<td style="text-align:left">用于进程调度，只有作业放入内存建立了相应的进程之后才能被分配处理机时间片</td>
</tr>
<tr>
<td>是否可抢占</td>
<td style="text-align:left">抢占式</td>
</tr>
<tr>
<td>优缺点</td>
<td style="text-align:left">优点：公平；响应快，适用于分时操作系统 缺点：由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td style="text-align:left">否</td>
</tr>
</tbody>
</table>
<h4 id="%E6%97%B6%E9%97%B4%E7%89%87%E5%A4%AA%E5%A4%A7">时间片太大</h4>
<p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p>
<h4 id="%E6%97%B6%E9%97%B4%E7%89%87%E5%A4%AA%E5%B0%8F">时间片太小</h4>
<p>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p>
<h3 id="%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">优先级调度算法</h3>
<p><strong>优先数</strong>越大，<strong>优先级</strong>越高</p>
<table>
<thead>
<tr>
<th>算法思想</th>
<th style="text-align:left">随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法规则</td>
<td style="text-align:left">每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</td>
</tr>
<tr>
<td>用于作业/进程调度</td>
<td style="text-align:left">既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中</td>
</tr>
<tr>
<td>是否可抢占</td>
<td style="text-align:left">都有，非抢占式只在进程主动放弃处理机时进行时调度。抢占式在··就绪队列变化时，检查是否会发生抢占</td>
</tr>
<tr>
<td>优缺点</td>
<td style="text-align:left">优点：公平；响应快，适用于分时操作系统 缺点：由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td style="text-align:left">会</td>
</tr>
</tbody>
</table>
<p>多级反馈队列调度算法</p>
<p><img src="操作系统/image-20241227202747603.png" alt="image-20241227202747603"></p>
<h3 id="%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">多级队列调度算法</h3>
<p>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</p>
<p><img src="操作系统/image-20241227204007232.png" alt="image-20241227204007232"></p>
<p>队列之间可采取固定优先级，或时间片划分</p>
<p>固定优先级：高优先级空时低优先级进程才能被调度</p>
<p>时间片划分：如三个队列分配时间50%，40%，10%</p>
<p>各队列可采用不同的调度策略，如：系统进程队列采用优先级调度</p>
<p>交互式队列采用时间片轮转</p>
<p>批处理队列采用先来先服务</p>
<h2 id="%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程同步</h2>
<p>并发性带来了异步性，有时需要通过进程同步解决这种异步问题，有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序。</p>
<h2 id="%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">进程互斥</h2>
<p>对临界资源的访问，需要互斥进行，<font color=red>即同一时间段内只能允许一个进程访问该资源</font></p>
<h3 id="%E5%9B%9B%E4%B8%AA%E9%83%A8%E5%88%86">四个部分</h3>
<p><strong>进入区</strong>：检查是否可进入临界区，若可进入，需要“上锁“
<strong>临界区</strong>：访问临界资源的那段代码
<strong>退出区</strong>：负责“解锁&quot;
<strong>剩余区</strong>：其余代码部分</p>
<h3 id="%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99">遵循的原则</h3>
<p>**空闲让进：**临界区空闲时，应允许一个进程访问
<strong>忙则等待</strong>：临界区正在被访问时，其他试图访问的进程需要等待
<strong>有限等待</strong>：要在有限时间内进入临界区，保证不会饥饿
<strong>让权等待</strong>：进不了临界区的进程，要释放处理机，防止忙等</p>
<h2 id="%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">进程互斥的软件实现方法</h2>
<h3 id="%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95">单标志法</h3>
<p>设置一个变量表示当前允许进入临界区的进程号，<font color=red>每个进程进入临界区的权限只能被另一个进程赋予</font></p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> <span class="hljs-built_in">turn</span> = <span class="hljs-number">0</span>;
<span class="hljs-comment">//p0进程：</span>
<span class="hljs-keyword">while</span>（<span class="hljs-built_in">turn</span> != <span class="hljs-number">0</span>);
critical section;
<span class="hljs-built_in">turn</span> = <span class="hljs-number">1</span>;
remainder section;

</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> <span class="hljs-built_in">turn</span> = <span class="hljs-number">0</span>;
<span class="hljs-comment">//p1进程：</span>
<span class="hljs-keyword">while</span>（<span class="hljs-built_in">turn</span> != <span class="hljs-number">1</span>);
critical section;
<span class="hljs-built_in">turn</span> = <span class="hljs-number">0</span>;
remainder section;

</div></code></pre>
<p>如果对方不使用，临界区就会一直空闲</p>
<p>违背了**<font color=red>空闲让进</font>**</p>
<h3 id="%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5">双标志先检查</h3>
<p><font color=red>先检查后上锁</font></p>
<p>设置个数组<font color=red>标记各进程想进入临界区的意愿</font></p>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> flag[<span class="hljs-number">2</span>];
flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;
flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;
<span class="hljs-comment">//p0进程：</span>
<span class="hljs-keyword">while</span>（flag[<span class="hljs-number">1</span>]);
flag[<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;
critical section;
flag[o]=<span class="hljs-literal">false</span>;
remainder section;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> flag[<span class="hljs-number">2</span>];
flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;
flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;
<span class="hljs-comment">//p0进程：</span>
<span class="hljs-keyword">while</span>（flag[<span class="hljs-number">0</span>]);
flag[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;
critical section;
flag[<span class="hljs-number">1</span>]=<span class="hljs-literal">false</span>;
remainder section;
</div></code></pre>
<p>检查和上锁不是一气呵成的，中间可能发生进程切换</p>
<p>违反<font color=red>忙则等待</font></p>
<h3 id="%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5">双标志后检查</h3>
<p><font color=red>先上锁后检查</font></p>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> flag[<span class="hljs-number">2</span>];
flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;
flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;
<span class="hljs-comment">//p0进程：</span>
flag[<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;
<span class="hljs-keyword">while</span>（flag[<span class="hljs-number">1</span>]);
critical section;
flag[o]=<span class="hljs-literal">false</span>;
remainder section;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> flag[<span class="hljs-number">2</span>];
flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;
flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;
<span class="hljs-comment">//p1进程：</span>
flag[<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;
<span class="hljs-keyword">while</span>（flag[<span class="hljs-number">1</span>]);
critical section;
flag[o]=<span class="hljs-literal">false</span>;
remainder section;
</div></code></pre>
<p><font color=red>解决了忙则等待，但违背了空闲让进，有限等待</font></p>
<p>会因各进程都长期无法访问临界资源而产生<font color=red>饥饿</font>现象</p>
<h3 id="peterson%E7%AE%97%E6%B3%95">Peterson算法</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> flag[<span class="hljs-number">2</span>];
<span class="hljs-keyword">int</span> <span class="hljs-built_in">turn</span> = <span class="hljs-number">1</span>;
flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;
flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;
<span class="hljs-comment">//p0进程：</span>
flag[<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;
<span class="hljs-built_in">turn</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">while</span>（flag[<span class="hljs-number">1</span>] &amp;&amp; <span class="hljs-built_in">turn</span>==<span class="hljs-number">1</span>);
critical section;
flag[o]=<span class="hljs-literal">false</span>;
remainder section;
<span class="hljs-comment">//p1进程</span>
flag[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;
<span class="hljs-built_in">turn</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span>（flag[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-built_in">turn</span>==<span class="hljs-number">0</span>);
critical section;
flag[<span class="hljs-number">1</span>]=<span class="hljs-literal">false</span>;
remainder section;
</div></code></pre>
<p><font color=red>遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则</font></p>
<h2 id="%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">进程互斥的硬件实现方法</h2>
<h3 id="%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95">中断屏蔽方法</h3>
<p>利用“开/关中断指令”</p>
<p>优点：简单高效</p>
<p>缺点：不适用于多处理机，只能用于内核进程，不适用于用户进程</p>
<h3 id="testandsettstsl%E6%8C%87%E4%BB%A4">TestAndSet（TS/TSL）指令</h3>
<p>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成，</p>
<p>TSL指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作</p>
<p>优点：实现简单，无需像软件实现那样严格检查是否会有逻辑漏洞；适用于多处理环境</p>
<p>缺点：不满足让权等待，暂时无法进入临界区的进程会占用CPU并且循环执行TSL，从而导致忙等</p>
<h3 id="swapexchangexchg%E6%8C%87%E4%BB%A4">Swap（Exchange/XCHG）指令</h3>
<p>优点：实现简单，无需像软件实现那样严格检查是否会有逻辑漏洞；适用于多处理环境</p>
<p>缺点：不满足让权等待，暂时无法进入临界区的进程会占用CPU并且循环执行TSL，从而导致忙等</p>
<h2 id="%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</h2>
<h1 id="%E6%AD%BB%E9%94%81">死锁</h1>
<h2 id="%E5%8E%9F%E5%9B%A0">原因：</h2>
<h3 id="a-%E7%AB%9E%E4%BA%89%E8%B5%84%E6%BA%90">a. 竞争资源</h3>
<p>系统中的资源可以分为两类：</p>
<p>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</p>
<p>另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</p>
<p>产生死锁中的竞争资源之一指的是竞争<code>不可剥夺资源</code>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</p>
<p>产生死锁中的竞争资源另外一种资源指的是<code>竞争临时资源</code>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p>
<h3 id="b-%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%8E%A8%E8%BF%9B%E9%A1%BA%E5%BA%8F%E9%9D%9E%E6%B3%95">b. 进程间推进顺序非法</h3>
<p>若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p>
<h2 id="%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">四个必要条件</h2>
<p><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
<strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。
<strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
<strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程--资源的环形链。</p>

</body>
</html>
